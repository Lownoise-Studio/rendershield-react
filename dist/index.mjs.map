{"version":3,"sources":["../src/hook.ts","../src/shallowCompare.ts","../src/pathCompare.ts","../src/report.ts","../src/hoc.ts"],"sourcesContent":["import { useMemo, useRef } from \"react\";\r\nimport type { RenderShieldOptions, RenderShieldDiff } from \"./types\";\r\nimport { getShallowDiff } from \"./shallowCompare\";\r\nimport { compareWatchedPaths } from \"./pathCompare\";\r\nimport { report } from \"./report\";\r\n\r\nexport function useRenderShield<T>(\r\n  props: T,\r\n  options?: RenderShieldOptions<T>\r\n): T {\r\n  const opts = options ?? {};\r\n  const prevRef = useRef<T | null>(null);\r\n  const renderCountRef = useRef(0);\r\n\r\n  renderCountRef.current += 1;\r\n\r\n  const prev = prevRef.current;\r\n\r\n  const decided = useMemo(() => {\r\n    // First render: accept incoming props.\r\n    // IMPORTANT: we still run useMemo so hook order is stable.\r\n    if (prev === null) {\r\n      return {\r\n        shielded: false,\r\n        nextValue: props,\r\n        shouldReportInitial: Boolean(opts.debug),\r\n        initialDiff: {\r\n          componentName: undefined,\r\n          shielded: false,\r\n          renderCount: renderCountRef.current,\r\n          changedKeys: [],\r\n          stableKeys: Object.keys((props as any) ?? {}),\r\n          watchedChanged: [],\r\n          watchedStable: opts.watch ?? [],\r\n          severity: \"Stable\",\r\n        } satisfies RenderShieldDiff,\r\n      };\r\n    }\r\n\r\n    // 1) Custom comparator wins (user-owned)\r\n    if (typeof opts.customCompare === \"function\") {\r\n      const equal = opts.customCompare(prev, props);\r\n\r\n      return {\r\n        shielded: equal,\r\n        nextValue: equal ? prev : props,\r\n        shouldReportInitial: false,\r\n        diff: buildDiff(prev, props, opts, renderCountRef.current, equal, true),\r\n      };\r\n    }\r\n\r\n    // 2) Default shallow compare\r\n    const shallow = getShallowDiff(prev as any, props as any);\r\n\r\n    // 3) Optional path-targeted deep compare for watch paths\r\n    if (opts.watch && opts.watch.length > 0) {\r\n      const watched = compareWatchedPaths(prev, props, opts.watch);\r\n\r\n      // Decision rule:\r\n      // - If watched paths are equal, we can shield even if unrelated keys changed\r\n      // - Otherwise, do not shield\r\n      const equal = watched.watchedEqual;\r\n\r\n      return {\r\n        shielded: equal,\r\n        nextValue: equal ? prev : props,\r\n        shouldReportInitial: false,\r\n        diff: buildDiff(\r\n          prev,\r\n          props,\r\n          opts,\r\n          renderCountRef.current,\r\n          equal,\r\n          false,\r\n          shallow,\r\n          watched\r\n        ),\r\n      };\r\n    }\r\n\r\n    // No watch paths: shallow equality decides\r\n    return {\r\n      shielded: shallow.equal,\r\n      nextValue: shallow.equal ? prev : props,\r\n      shouldReportInitial: false,\r\n      diff: buildDiff(\r\n        prev,\r\n        props,\r\n        opts,\r\n        renderCountRef.current,\r\n        shallow.equal,\r\n        false,\r\n        shallow\r\n      ),\r\n    };\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [props, opts.watch?.join(\"|\"), opts.debug, opts.customCompare]);\r\n\r\n  // First render commit: store props AFTER memo runs (same render, safe)\r\n  if (prev === null) {\r\n    prevRef.current = props;\r\n\r\n    if (decided.shouldReportInitial && (decided as any).initialDiff) {\r\n      report((decided as any).initialDiff);\r\n    }\r\n\r\n    return props;\r\n  }\r\n\r\n  // Debug reporting (non-initial renders)\r\n  if (opts.debug && (decided as any).diff) {\r\n    report((decided as any).diff);\r\n  }\r\n\r\n  if (decided.shielded) {\r\n    // Keep prevRef as-is (shield)\r\n    return prevRef.current as T;\r\n  }\r\n\r\n  // Accept new props\r\n  prevRef.current = props;\r\n  return props;\r\n}\r\n\r\nfunction buildDiff<T>(\r\n  prev: T,\r\n  next: T,\r\n  opts: RenderShieldOptions<T>,\r\n  renderCount: number,\r\n  equal: boolean,\r\n  usedCustom: boolean,\r\n  shallow?: { changedKeys: string[]; stableKeys: string[] },\r\n  watched?: { watchedChanged: string[]; watchedStable: string[] }\r\n): RenderShieldDiff {\r\n  const changedKeys =\r\n    shallow?.changedKeys ?? safeTopKeysDiff(prev, next).changedKeys;\r\n  const stableKeys =\r\n    shallow?.stableKeys ?? safeTopKeysDiff(prev, next).stableKeys;\r\n\r\n  const watchedChanged = watched?.watchedChanged ?? [];\r\n  const watchedStable = watched?.watchedStable ?? [];\r\n\r\n  const severity = usedCustom\r\n    ? \"Custom compare triggered\"\r\n    : watched && watchedChanged.length > 0\r\n      ? \"Changed (watched key)\"\r\n      : changedKeys.length > 0\r\n        ? \"Changed (non-UI key)\"\r\n        : \"Stable\";\r\n\r\n  return {\r\n    componentName: undefined,\r\n    shielded: equal,\r\n    renderCount,\r\n    changedKeys,\r\n    stableKeys,\r\n    watchedChanged,\r\n    watchedStable,\r\n    severity,\r\n  };\r\n}\r\n\r\nfunction safeTopKeysDiff(prev: any, next: any) {\r\n  try {\r\n    return getShallowDiff(prev, next);\r\n  } catch {\r\n    return { equal: false, changedKeys: [\"(unavailable)\"], stableKeys: [] };\r\n  }\r\n}\r\n","export function getShallowDiff(prev: any, next: any): {\r\n    equal: boolean;\r\n    changedKeys: string[];\r\n    stableKeys: string[];\r\n  } {\r\n    if (Object.is(prev, next)) {\r\n      // Same reference or both NaN, etc.\r\n      return { equal: true, changedKeys: [], stableKeys: keysOf(next) };\r\n    }\r\n  \r\n    // Non-objects: strict identity check is enough\r\n    if (!isObject(prev) || !isObject(next)) {\r\n      return { equal: false, changedKeys: [\"(value)\"], stableKeys: [] };\r\n    }\r\n  \r\n    const prevKeys = Object.keys(prev);\r\n    const nextKeys = Object.keys(next);\r\n  \r\n    // Build key universe (shallow compare is O(n) over top-level keys)\r\n    const keySet = new Set<string>([...prevKeys, ...nextKeys]);\r\n  \r\n    const changedKeys: string[] = [];\r\n    const stableKeys: string[] = [];\r\n  \r\n    for (const k of keySet) {\r\n      const a = (prev as any)[k];\r\n      const b = (next as any)[k];\r\n      if (Object.is(a, b)) stableKeys.push(k);\r\n      else changedKeys.push(k);\r\n    }\r\n  \r\n    return { equal: changedKeys.length === 0, changedKeys, stableKeys };\r\n  }\r\n  \r\n  function isObject(v: any): v is Record<string, any> {\r\n    return v !== null && typeof v === \"object\";\r\n  }\r\n  \r\n  function keysOf(v: any): string[] {\r\n    return isObject(v) ? Object.keys(v) : [];\r\n  }\r\n  ","export function getAtPath(obj: any, path: string): any {\r\n    if (obj == null) return undefined;\r\n    const parts = normalizePath(path);\r\n    let cur = obj;\r\n    for (const p of parts) {\r\n      if (cur == null) return undefined;\r\n      cur = cur[p as any];\r\n    }\r\n    return cur;\r\n  }\r\n  \r\n  /**\r\n   * Deep compare ONLY the values at watched paths.\r\n   * This is intentionally targeted: no full-object deep recursion.\r\n   */\r\n  export function compareWatchedPaths<T>(\r\n    prev: T,\r\n    next: T,\r\n    watch: string[]\r\n  ): {\r\n    watchedChanged: string[];\r\n    watchedStable: string[];\r\n    watchedEqual: boolean;\r\n  } {\r\n    const watchedChanged: string[] = [];\r\n    const watchedStable: string[] = [];\r\n  \r\n    for (const p of watch) {\r\n      const a = getAtPath(prev as any, p);\r\n      const b = getAtPath(next as any, p);\r\n  \r\n      if (deepEqual(a, b)) watchedStable.push(p);\r\n      else watchedChanged.push(p);\r\n    }\r\n  \r\n    return {\r\n      watchedChanged,\r\n      watchedStable,\r\n      watchedEqual: watchedChanged.length === 0,\r\n    };\r\n  }\r\n  \r\n  /**\r\n   * Minimal deep equality for watched values.\r\n   * - Cycle-safe\r\n   * - Handles primitives, arrays, plain objects\r\n   * - Not intended for huge graphs (watch paths should stay small + intentional)\r\n   */\r\n  export function deepEqual(a: any, b: any, seen = new WeakMap<object, object>()): boolean {\r\n    if (Object.is(a, b)) return true;\r\n  \r\n    const aObj = isObject(a);\r\n    const bObj = isObject(b);\r\n    if (!aObj || !bObj) return false;\r\n  \r\n    // Cycle handling\r\n    const aSeen = seen.get(a);\r\n    if (aSeen && aSeen === b) return true;\r\n    seen.set(a, b);\r\n  \r\n    if (Array.isArray(a) || Array.isArray(b)) {\r\n      if (!Array.isArray(a) || !Array.isArray(b)) return false;\r\n      if (a.length !== b.length) return false;\r\n      for (let i = 0; i < a.length; i++) {\r\n        if (!deepEqual(a[i], b[i], seen)) return false;\r\n      }\r\n      return true;\r\n    }\r\n  \r\n    const aKeys = Object.keys(a);\r\n    const bKeys = Object.keys(b);\r\n    if (aKeys.length !== bKeys.length) return false;\r\n  \r\n    // Ensure same keys\r\n    for (const k of aKeys) {\r\n      if (!Object.prototype.hasOwnProperty.call(b, k)) return false;\r\n    }\r\n  \r\n    for (const k of aKeys) {\r\n      if (!deepEqual((a as Record<string, any>)[k], (b as Record<string, any>)[k], seen)) return false;\r\n    }\r\n  \r\n    return true;\r\n  }\r\n  \r\n  function isObject(v: any): v is object {\r\n    return v !== null && typeof v === \"object\";\r\n  }\r\n  \r\n  function normalizePath(path: string): Array<string | number> {\r\n    // Supports: \"user.id\", \"items[0].name\", \"items.0.name\"\r\n    const out: Array<string | number> = [];\r\n    const cleaned = path.replace(/\\[(\\d+)\\]/g, \".$1\");\r\n    for (const part of cleaned.split(\".\").filter(Boolean)) {\r\n      const n = Number(part);\r\n      out.push(Number.isInteger(n) && String(n) === part ? n : part);\r\n    }\r\n    return out;\r\n  }\r\n  ","import type { RenderShieldDiff } from \"./types\";\r\n\r\n/**\r\n * Dev-only reporter with micro-task batching.\r\n *\r\n * Goal:\r\n * - Collapse repeated reports for the same \"logical event\" within one micro-task.\r\n * - Reduce Strict Mode double-invoke noise without relying on React internals.\r\n *\r\n * Notes:\r\n * - This does NOT hide legitimate later renders (different ticks).\r\n * - This does NOT mutate inputs.\r\n * - Production logs remain disabled.\r\n */\r\n\r\ntype Pending = {\r\n  key: string;\r\n  diff: RenderShieldDiff;\r\n};\r\n\r\nlet pendingReports: Map<string, Pending> = new Map();\r\nlet isBatching = false;\r\n\r\nexport function report(diff: RenderShieldDiff) {\r\n  const isProd =\r\n    typeof process !== \"undefined\" &&\r\n    process.env &&\r\n    process.env.NODE_ENV === \"production\";\r\n\r\n  if (isProd) return;\r\n\r\n  const key = buildBatchKey(diff);\r\n\r\n  // Store latest diff for this key in the current micro-task.\r\n  pendingReports.set(key, { key, diff });\r\n\r\n  if (!isBatching) {\r\n    isBatching = true;\r\n    Promise.resolve().then(flush);\r\n  }\r\n}\r\n\r\nfunction flush() {\r\n  for (const { diff } of pendingReports.values()) {\r\n    renderLog(diff);\r\n  }\r\n  pendingReports.clear();\r\n  isBatching = false;\r\n}\r\n\r\nfunction renderLog(diff: RenderShieldDiff) {\r\n  const name = diff.componentName ? `<${diff.componentName}>` : \"<Component>\";\r\n  const title = `[RenderShield] ${name}`;\r\n\r\n  console.groupCollapsed(title);\r\n  console.log(\"Shielded:\", diff.shielded);\r\n  console.log(\"Render count:\", diff.renderCount);\r\n  console.log(\"Changed:\", diff.changedKeys);\r\n  console.log(\"Stable:\", diff.stableKeys);\r\n\r\n  if (diff.watchedChanged.length || diff.watchedStable.length) {\r\n    console.log(\"Watched changed:\", diff.watchedChanged);\r\n    console.log(\"Watched stable:\", diff.watchedStable);\r\n  }\r\n\r\n  console.log(\"Severity:\", diff.severity);\r\n  console.groupEnd();\r\n}\r\n\r\n/**\r\n * Build a best-effort batching key.\r\n *\r\n * Why not only componentName?\r\n * - Hook reports often omit componentName.\r\n * - Multiple instances of same componentName can render in the same tick.\r\n *\r\n * This key aims to collapse genuinely duplicated logs within a micro-task\r\n * while avoiding accidental overwrites of unrelated anonymous reports.\r\n */\r\nfunction buildBatchKey(diff: RenderShieldDiff): string {\r\n  const base = diff.componentName ?? \"Anonymous\";\r\n\r\n  // Include minimal, factual signature of the report.\r\n  // This is not \"magic\": it is derived from the report content itself.\r\n  const signature = [\r\n    diff.shielded ? \"S1\" : \"S0\",\r\n    diff.severity,\r\n    diff.changedKeys.join(\",\"),\r\n    \"|W|\",\r\n    diff.watchedChanged.join(\",\"),\r\n  ].join(\":\");\r\n\r\n  return `${base}::${signature}`;\r\n}\r\n","import React from \"react\";\r\nimport type { RenderShieldOptions } from \"./types\";\r\nimport { getShallowDiff } from \"./shallowCompare\";\r\nimport { compareWatchedPaths } from \"./pathCompare\";\r\nimport { report } from \"./report\";\r\n\r\nexport function withRenderShield<P extends object>(\r\n  Component: React.ComponentType<P>,\r\n  options?: RenderShieldOptions<P>\r\n) {\r\n  const opts = options ?? {};\r\n  const name = Component.displayName || Component.name || \"Component\";\r\n\r\n  const Memo = React.memo(Component, (prevProps, nextProps) => {\r\n    // Custom comparator wins (user-owned)\r\n    if (typeof opts.customCompare === \"function\") {\r\n      const equal = opts.customCompare(prevProps, nextProps);\r\n\r\n      if (opts.debug) {\r\n        report({\r\n          componentName: name,\r\n          shielded: equal,\r\n          renderCount: NaN, // comparator is not a render, so we avoid lying\r\n          changedKeys: [],\r\n          stableKeys: [],\r\n          watchedChanged: [],\r\n          watchedStable: [],\r\n          severity: \"Custom compare triggered\",\r\n        });\r\n      }\r\n\r\n      return equal;\r\n    }\r\n\r\n    const shallow = getShallowDiff(prevProps, nextProps);\r\n\r\n    if (opts.watch && opts.watch.length > 0) {\r\n      const watched = compareWatchedPaths(prevProps, nextProps, opts.watch);\r\n      const equal = watched.watchedEqual;\r\n\r\n      if (opts.debug) {\r\n        report({\r\n          componentName: name,\r\n          shielded: equal,\r\n          renderCount: NaN,\r\n          changedKeys: shallow.changedKeys,\r\n          stableKeys: shallow.stableKeys,\r\n          watchedChanged: watched.watchedChanged,\r\n          watchedStable: watched.watchedStable,\r\n          severity:\r\n            watched.watchedChanged.length > 0\r\n              ? \"Changed (watched key)\"\r\n              : shallow.changedKeys.length > 0\r\n                ? \"Changed (non-UI key)\"\r\n                : \"Stable\",\r\n        });\r\n      }\r\n\r\n      return equal;\r\n    }\r\n\r\n    if (opts.debug) {\r\n      report({\r\n        componentName: name,\r\n        shielded: shallow.equal,\r\n        renderCount: NaN,\r\n        changedKeys: shallow.changedKeys,\r\n        stableKeys: shallow.stableKeys,\r\n        watchedChanged: [],\r\n        watchedStable: [],\r\n        severity: shallow.changedKeys.length > 0 ? \"Changed (non-UI key)\" : \"Stable\",\r\n      });\r\n    }\r\n\r\n    return shallow.equal;\r\n  });\r\n\r\n  Memo.displayName = `withRenderShield(${name})`;\r\n  return Memo;\r\n}\r\n"],"mappings":"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","names":["useMemo","useRef","getShallowDiff","prev","next","keysOf","isObject","prevKeys","nextKeys","keySet","changedKeys","stableKeys","k","a","b","v","getAtPath","obj","path","parts","normalizePath","cur","p","compareWatchedPaths","prev","next","watch","watchedChanged","watchedStable","a","b","deepEqual","seen","aObj","isObject","bObj","aSeen","i","aKeys","bKeys","k","v","out","cleaned","part","n","pendingReports","isBatching","report","diff","key","buildBatchKey","flush","renderLog","title","base","signature","useRenderShield","props","options","opts","prevRef","useRef","renderCountRef","prev","decided","useMemo","equal","buildDiff","shallow","getShallowDiff","watched","compareWatchedPaths","report","next","renderCount","usedCustom","changedKeys","safeTopKeysDiff","stableKeys","watchedChanged","watchedStable","severity","React","withRenderShield","Component","options","opts","name","Memo","React","prevProps","nextProps","equal","report","shallow","getShallowDiff","watched","compareWatchedPaths"]}